/ *
 Droit d'auteur (C) Federico Zivolo 2018
 Distribué sous licence MIT (les termes de la licence sont disponibles sur http://opensource.org/licenses/MIT).
 * / (function (e, t) {'object' == typeof exporte && 'undefined'! = typeof module? module.exports = t (): 'function' == typeof définit && define.amd? define (t): e. Popper = t ()}) (this, function () {'use strict'; fonction e (e) {return e && '[objet Fonction]' === {}. ToString.call (e)} fonction t (e , t) {if (1! == e.nodeType) renvoie []; var o = getComputedStyle (e, null); retourne t? o [t]: o} fonction o (e) {return'HTML '== = e.nodeName? e: e.parentNode || e.host} fonction n (e) {if (! e) retourne document.body; switch (e.nodeName) {case'HTML ': case'BODY': retourne e.ownerDocument.body; case '# document': renvoie e.body;} var i = t (e), r = i.overflow, p = i.overflowX, s = i.overflowY; return / (auto | défilement | overlay) /. test (r + s + p)? e: n (o (e))} fonction r (e) {return 11 === e? re: 10 === e? pe: re || pe} fonction p (e) {if (! e) renvoie document.documentElement;pour (var o = r (10)? document.body: null, n = e.offsetParent; n === o && e.nextElementSibling;) n = (e = e.nextElementSibling) .offsetParent; var i = n && n.nodeName; retour i && 'BODY'! == i && 'HTML'! == i? -1! == ['TD', 'TABLE']. indexOf (n.nodeName) && 'static' === t (n, ' position ')? p (n): n: e? e.ownerDocument.documentElement: document.documentElement} fonction s (e) {var t = e.nodeName; return'BODY'! == t && ('HTML' == = t || p (e.firstElementChild) === e)} fonction d (e) {return null === e.parentNode? e: d (e.parentNode)} fonction a (e, t) {if ( ! e ||! e.nodeType ||! t ||! t.nodeType) return document.documentElement; var o = e.compareDocumentPosition (t) & Node.DOCUMENT_POSITION_FOLLOWING, n = o? e: t, i = o? t : e, r = document.createRange (); r.setStart (n, 0); r.setEnd (i, 0); var l = r.commonAncestorContainer; if (e! == l && t! == l || n .contient (i)) retourne s (l)? l: p (l); var f = d (e); retourne f.host?a(f.host,t):a(e,d(t).host }} function l (e) {var t = 1 <arguments.length && void 0! == arguments [1]? arguments [1]: 'top', o = 'top' === t '' scrollTop ':' scrollLeft ', n = e.nodeName; if (' BODY '=== n ||' HTML '=== n) {var i = e.ownerDocument.documentElement, r = e.ownerDocument.scrollingElement || i, retourne r [o]} return e [o]} fonction f (e, t) {var o = 2 <arguments.length && void 0! == arguments [2] && arguments [2], n = l (t, 'top'), i = l (t, 'gauche'), r = o? -1: 1, retour e.top + = n * r, e.bottom + = n * r, e.left + = i * r, e.right + = i * r, e} fonction m (e, t) {var o = 'x' === t '' Gauche ':' Haut ', n =' Gauche '== o?' Droite ':' Bas '; parseFloat (e ['bordure' + o + 'Largeur'], 10) + parseFloat (e ['bordure' + n + 'Largeur'], 10)} fonction h (e, t, o,n) {return $ (t ['offset' + e], t ['scroll' + e], o ['client' + e], o ['offset' + e], o ['scroll' + e] , r (10)? o ['décalage' + e] + n ['marge' + ('Hauteur' === e? 'Haut': 'Gauche')] + n ['marge' + ('Hauteur' === e? 'Bottom': 'Droite')]: 0)} fonction c () {var e = document.body, t = document.documentElement, o = r (10) && getComputedStyle (t); return {hauteur : h ('Hauteur', e, t, o), largeur: h ('Largeur', e, t, o)}} fonction g (e) {return le ({}, e, {droite: e.left + e.width, en bas: e.top + e.height})} u (e) {var o = {}; essayer {if (r (10)) {o = e.getBoundingClientRect (); var n = l (e, 'top'), i = l (e, 'gauche'); o.top + = n, o.left + = i, o.bottom + = n, o.right + = i} sinon o = e.getBoundingClientRect ()} catch (t) {} var p = {gauche: o.left, haut: o.top, largeur: o.right-o.left, hauteur: o.bottom-o.top}, s = 'HTML '=== e.nodeName? c (): {}, d = s.width || e.clientWidth || p.pight-p.left, a = s.highlight || e.clientHeight || p.bottom-p.top, f = e.offsetWidth-d, h = e.offsetHauteur- a, si (f || h) {var u = t (e); f- = m (u, 'x'), h- = m (u, 'y'), p.width- = f, p .height- = h} return g (p)} fonction b (e, o) {var i = 2 <arguments.length && void 0! == arguments [2] && arguments [2], p = r (10), s = 'HTML' === o.nodeName, d = u (e), a = u (o), l = n (e), m = t (o), h = parseFloat (m.borderTopWidth, 10), c = parseFloat (m.borderLeftWidth, 10); i && 'HTML' === o.noeudNom && (a.top = $ (a.top, 0), a.left = $ (a.gauche, 0)); var b = g ({top: d.top-a.top-h, à gauche: d.left-a.left-c, largeur: d.width, hauteur: d.height}); if (b.marginTop = 0, b.marginLeft = 0,! p && s) {var y = parseFloat (m.marginTop, 10), w = parseFloat (m.marginLeft, 10), b.top- = hy, b.bottom- = hy, b.left - = cw, b.right- = cw, b.marginTop = y, b.marginLeft = w} retour (p &&! i? o.contains (l): o === l && 'BODY '! == l.nodeName) && (b = f (b, o)), b} fonction y (e) {var t = 1 <arguments.length && void 0! == arguments [1] && arguments [1], o = e.ownerDocument.documentElement, n = b (e, o), i = $ (o.clientWidth, window.innerWidth || 0), r = $ (o.clientHeight, window.innerHauteur || 0), p = t? 0: l (o), s = t? 0: l (o, 'gauche'), d = {haut: pn.top + n.margeTop, gauche: sn.left + n.marginLeft, largeur: i, height: r}; return g (d)} fonction w (e) {var n = e.noeudNom; return'BODY '=== n ||' HTML '=== n?! 1:' fixe ' === t (e, 'position') || w (o (e))} fonction E (e) {if (! e ||! e.parentElement || r ()) retourne document.documentElement; for ( var o = e.parentElement; o && 'none' === t (o, 'transform');) o = o.parentElement; return o || document.documentElement} fonction v (e, t, i, r) { var p = 4 <arguments.length && void 0! == arguments [4] && arguments [4], s = {haut: 0, gauche: 0}, d = p? E (e): a (e, t);if ('viewport' === r) s = y (d, p); else {var l; 'scrollParent' === r (l = n (o (t)), 'BODY' === l .nodeName && (l = e.ownerDocument.documentElement)): 'window' === r? l = e.ownerDocument.documentElement: l = r; var f = b (l, d, p); if ('HTML' === l.nodeName &&! w (d)) {var m = c (), h = m.la hauteur, g = m.largeur; s.top + = f.top-f.margeTop, s.bottom = h + f.top, s.left + = f.left-f.marginLeft, s.right = g + f.left} sinon s = f} retour s.gauche + = i, s.top + = i, s.right- = i , s.bottom- = i, s} fonction x (e) {var t = e.width, o = e.height; retourne t * o} fonction O (e, t, o, n, i) {var r = 5 <arguments.length && void 0! == arguments [5]? Arguments [5]: 0; if (-1 === e.indexOf ('auto')) retourne e; var p = v (o, n, r, i), s = {haut: {largeur: largeur, hauteur: t.top-p.top}, droite: {largeur: p.right-t.right, hauteur: p.height}, bas: {width: p.width, height: p.bottom-t.bottom}, à gauche: {width: t.left-p.left, hauteur: p.height}}, d = Object.keys (s).map (function (e) {return le ({clé: e}, s [e], {zone: x (s [e])})}. sort (fonction (e, t) {return t.area- e.area}), a = d.filter (fonction (e) {var t = e.largeur, n = e.hauteur, retour t> = o.clientWidth && n> = o.clientHauteur}), l = 0 <a .length? a [0] .key: d [0] .key, f = e.split ('-') [1]; return l + (f? '-' + f: '')} fonction L (e , t, o) {var n = 3 <arguments.length && void 0! == arguments [3]? arguments [3]: null, i = n? E (t): a (t, o); return b (o , i, n)} S (e) de fonction {var t = getComputedStyle (e), o = parseFloat (t.marginTop) + parseFloat (t.marginBottom), n = parseFloat (t.marginLeft) + parseFloat (t.marginRight ), i = {width: e.offsetWidth + n, hauteur: e.offsetHeight + o}; return i} fonction T (e) {var t = {gauche: 'droite', droite: 'gauche', bas: ' top ', top:' bottom '}; return e.replace (/ left | right | bottom | top / g, fonction (e) {return t [e]})} fonction C (e, t, o) {o = o.split ('-') [0];var n = S (e), i = {largeur: n.largeur, hauteur: n.hauteur}, r = -1! == ['droite', 'gauche']. indexOf (o), p = r? 'haut': 'gauche', s = r 'gauche': 'haut', d = r 'hauteur': 'largeur', a = r '' largeur ':' hauteur ', retour i [p] = t [p] + t [d] / 2-n [d] / 2, i [s] = o === s? t [s] -n [a]: t [T (s)], i} fonction D (e, t) {return Array.prototype.find? e.find (t): e.filter (t) [0]} fonction N (e, t, o) {if (Array.prototype.findIndex) return e.findIndex (fonction (e) {return e [t] === o}); var n = D (e, fonction (e) {return e [t] === o}); return e.indexOf (n)} fonction P (t, o, n) {var i = vide 0 === n? t: t.slice (0, N (t, 'nom', n)); return i.forEach (fonction (t) {t ['function'] && console.warn ('`modifier.function` est obsolète, utilisez` modifier.fn`!'); var n = t ['function'] || t.fn; t. activé && e (n) && (o.offsets.popper = g (o.offsets.popper), o.offsets.reference = g (o.offsets.reference), o = n (o, t))}), o} fonction k () {if (! this.state.isDestroyed) {var e = {instance: this, styles: {}, styles_flèches: { }, attributs: {}, retourné:! 1, offsets: {}}; e.offsets.reference = L (this.state, this.popper, this.reference, this.options.positionFixed), e.placement = O (this.options.placement, e.offsets.reference, this.popper, this.reference, this.options.modifiers.flip.boundariesElement, this.options.modifiers.flip.padding), e.originalPlacement = e.placement, e.positionFixed = this.options.positionFixed, e.offsets.popper = C (this.popper, e.offsets.reference, e.placement), e.offsets.popper.position = this.options.positionFixed? 'fixe' : 'absolute', e = P (this.modifiers, e), this.state.isCreated? this.options.onUpdate (e) :( this.state.isCreated =! 0, this.options.onCrée (e)) }} W (e, t) {return e.some (fonction (e) {var o = e.nom, n = e.enabled, return n &&o === t})} la fonction B (e) {pour (var t = [! 1, 'ms', 'Webkit', 'Moz', 'O'], o = e.charAt (0) .àUpperCase () + e.slice (1), n ​​= 0; n <t.length; n ++) {var i = t [n], r = i? '' + i + o: e; if ('non défini'! = typeof document.body.style [r]) return r} renvoie null} fonction H () {retourne this.state.isDestroyed =! 0, W (this.modifiers, 'applyStyle') && (this.popper.removeAttribute ( 'x-placement'), this.popper.style.position = '', this.popper.style.top = '', this.popper.style.left = '', this.popper.style.right = '' , this.popper.style.bottom = '', this.popper.style.willChange = '', this.popper.style [B ('transform')] = ''), this.disableEventListeners (), this.options .removeOnDestroy && this.popper.parentNode.removeChild (this.popper), cette} fonction A (e) {var t = e.ownerDocument; retourne t? t.defaultView:fenêtre} fonction M (e, t, o, i) {var r = 'BODY' === e.nodeName, p = r? e.ownerDocument.defaultView: e; p.addEventListener (t, o, {passif: ! 0}), r || M (n (p.parentNode), t, o, i), i.push (p)} fonction I (e, t, o, i) {o.updateBound = i, A (e) .addEventListener ('redimensionner', o.updateBound, {passif:! 0}); var r = n (e); retourner M (r, 'scroll', o.updateBound, o.scrollParents), o. scrollElement = r, o.eventsEnabled =! 0, o} fonction F () {this.state.eventsEnabled || (this.state = I (this.reference, this.options, this.state, this.scheduleUpdate))} fonction R (e, t) {return A (e) .removeEventListener ('redimensionner', t.updateBound), t.scrollParents.forEach (fonction (e) {e.removeEventListener ('scroll', t.updateBound)}) , t.updateBound = null, t.scrollParents = [], t.scrollElement = null, t.eventsEnabled =! 1, t} fonction U () {this.state.eventsEnabled && (cancelAnimationFrame (this.scheduleUpdate), this.state = R (ceci.reference, this.state))} la fonction Y (e) {return ''! == e &&! isNaN (parseFloat (e)) && isFinite (e)} la fonction j (e, t) {Object.keys (t) .forEach (fonction (o) {var n = ''; - 1! == ['largeur', 'hauteur', 'haut', 'droite', 'bas', 'gauche']. indexOf (o) && Y (t [o]) && (n = 'px'), e.style [o] = t [o] + n})} fonction K (e, t) {Object.keys (t) .forEach (fonction (o) {var n = t [o] ;! 1 === n? e.removeAttribute (o): e.setAttribute (o, t [o])})} fonction q (e, t, o) {var n = D (e, fonction (e) {var o = e.nom; return o === t}), i = !! n && e.some (fonction (e) {return e.name === o && e.enabled && e.order <n.order}); if (! i) {var r = '`' + t + '`'; console.warn (le modificateur '' '+ o +' '' + 'est requis par le modificateur' + r + 'dans l'ordre pour travailler, assurez-vous de l'inclure avant '+ r +'! ')} return i} la fonction G (e) {return'end '=== e' 'start': 'start' === e? 'end': e} la fonction z (e) {var t = 1 <arguments .length && void 0! == arguments [1] && arguments [1], o = me.indexOf (e), n = me.slice (o + 1) .concat (me.slice (0, o)), retourne t? n.reverse (): n} fonction V (e, t, o, n) {var i = e.match (/ ((?: \ - | \ +)? \ d * \.? \ d *) ( . *) /), r = + i [1], p = i [2]; si (! r) renvoie e; if (0 === p.indexOf ('%')) {var s; p) {case '% p': s = o; break; cas '%': cas '% r': défaut: s = n;} var d = g (s); return d [t] / 100 * r } if ('vh' === p || 'vw' === p) {var a; renvoyer a = 'vh' === p? $ (document.documentElement.clientHeight, window.innerHeight || 0) : $ (document.documentElement.clientWidth, window.innerWidth || 0), a / 100 * r} renvoie r} fonction _ (e, t, o, n) {var i = [0,0], r = - 1! == ['right', 'left']. IndexOf (n), p = e.split (/ (\ + | \ -) ​​/). Map (fonction (e) {return e.trim ()}), s = p.indexOf (D (p, fonction (e) {return-1! == e.search (/, | \ s /)})); p [s] && - 1 = == p [s] .indexOf (',') && console.warn ('Les offsets séparés par des espaces blancs sont obsolètes, utilisez une virgule (,) à la place.'); var d = / \ s *, \ s * | \ s + /, a = -1 === s? [p]: [p.slice (0, s) .concat ([p [s] .split (d) [0]]), [p [ s] .split (d) [1]]. concat (p.slice (s + 1))]; return a = a.map (fonction (e, n) {var i = (1 === n ?! r:?) 'hauteur': 'largeur', p =! 1, retourne e.reduce (fonction (e, t) {return '' === e [e.length-1] && - 1! == ['+', '-']. indexOf (t)? (e [e.length-1] = t, p =! 0, e): p? (e [e.length-1] + = t, p =! 1, e): e.concat (t)}, []). map (fonction (e) {return V (e, i, t, o)})), a.forEach (fonction (e , t) {e.forEach (fonction (o, n) {Y (o) && (i [t] + = o * ('-' === e [n-1]? - 1: 1))} )}), i} fonction X (e, t) {var o, n = t.offset, i = e.placement, r = e.offsets, p = r.popper, s = r.reference, d = i .Divisé('-') [0]; return o = Y (+ n)? [+ N, 0]: _ (n, p, s, d), 'gauche' === d? (P.top + = o [0], p.left- = o [1]): 'right' === d? (p.top + = o [0], p.left + = o [1]): 'top' === d? (p. gauche + = o [0], p.top- = o [1]): 'bas' === d && (p.gauche + = o [0], p.top + = o [1]), e.popper = p , e} pour (var J = Math.min, Q = Math.round, Z = Math.floor, $ = Math.max, ee = 'undefined'! = typeof fenêtre && 'undefined'! = typeof document, te = [ 'Edge', 'Trident', 'Firefox'], oe = 0, ne = 0; ne <te.length; ne + = 1) si (ee && 0 <= navigator.userAgent.indexOf (te [ne])) {oe = 1; break} var i = ee && window.Promise, ie = i? Function (e) {var t =! 1; retourne la fonction () {t || (t =! 0, window.Promise.resolve (). (function () {t =! 1, e ()})}}: fonction (e) {var t =! 1; retourne la fonction () {t || (t =! 0, setTimeout (function () { t =! 1, e ()}, oe))}}, re = ee && !! (window.MSInputMethodContext && document.documentMode), pe = ee && / MSIE 10 / .test (navigator.userAgent), se = fonction (e, t) {if (! (E instanceof t)) lance une nouvelle erreur TypeError ('Impossible d'appeler une classe en tant que fonction')}, de = function () {fonction e (e, t) {pour (var o, n = 0; n <t.longueur; n ++) o = t [n], o.enumerable = o.enumerable ||! 1, o.configurable =! 0, 'value' dans o && (o.writable =! 0), Object.defineProperty (e, o.key, o)} fonction de retour (t, o, n) {return o && e (t.prototype, o) , n && e (t, n), t}} (), ae = fonction (e, t, o) {return t dans e? Object.defineProperty (e, t, {valeur: o, énumérable:! 0, configurable: ! 0, inscriptible:! 0}): e [t] = o, e}, le = Objet.assign || fonction (e) {pour (var t, o = 1; o <arguments.length; o ++) pour (var n dans t = arguments [o], t) Object.prototype.hasOwnProperty.call (t, n) && (e [n] = t [n]); return e}, fe = ['auto-start' , 'auto', 'auto-end', 'top-start', 'top', 'top-end', 'right-start', 'right ',' right-end ',' bottom-end ',' bottom ',' bottom-start ',' left-end ',' left ',' left-start '], moi = fe.slice (3) , il = {FLIP: 'flip', CLOCKWISE: 'sens horaire', COUNTERCLOCKWISE: 'sens antihoraire'}, ce = function () {fonction t (o, n) {var i = cela, r = 2 <arguments.length && void 0 ! == arguments [2]? arguments [2]: {}; se (this, t), this.scheduleUpdate = fonction () {return requestAnimationFrame (i.update)}, this.update = c'est-à-dire (this.update. bind (this)), this.options = le ({}, t.Défauts, r), this.state = {isDestroyed:! 1, isCreated:! 1, scrollParents: []}, this.reference = o && o.jquery ? o [0]: o, this.popper = n && n.jquery? n [0]: n, this.options.modifiers = {}, Object.keys (le ({}, t.Defaults.modifiers, r.modifiers )). forEach (fonction (e) {i.options.modifiers [e] = le ({}, t.Defaults.modifiers [e] || {}, r.modifiers? r.modifiers [e]: {} )}),this.modifiers = Object.keys (this.options.modifiers) .map (fonction (e) {return le ({nom: e}, i.options.modifiers [e])}). sort (fonction (e, t ) {return e.order-t.order}), this.modifiers.forEach (fonction (t) {t.enabled && e (t.onLoad) && t.onLoad (i.référence, i.popper, i.options, t, i.state)}), this.update (); var p = ce.options.eventsEnabled; p && this.enableEventListeners (), this.state.eventsEnabled = p} return de (t, [{key: 'update', valeur : function () {return k.call (this)}}, {clé: 'destroy', valeur: function () {retourne H.call (this)}}, {clé: 'enableEventListeners', valeur: function () {return F.call (this)}}, {clé: 'disableEventListeners', valeur: function () {retourne U.call (this)}}], t} (); renvoie ce.Utils = ('non défini' == typeof window? global: fenêtre) .PopperUtils, ce.placements = fe, ce.Defaults = {placement: 'bottom', positionFixed:! 1, eventsEnabled :!0, removeOnDestroy:! 1, onCreate: function () {}, onUpdate: function () {}, modificateurs: {shift: {ordre: 100, activé:! 0, fn: function (e) {var t = e. placement, o = t.split ('-') [0], n = t.split ('-') [1]; si (n) {var i = e.offsets, r = i.reference, p = i.popper, s = -1! == ['bas', 'haut']. indexOf (o), d = s? 'gauche': 'haut', a = s '' largeur ':' hauteur ', l = {début: ae ({}, d, r [d]), fin: ae ({}, d, r [d] + r [a] -p [a])}; e.offsets.popper = le ({}, p, l [n])} return e}}, offset: {ordre: 200, activé:! 0, fn: X, décalage: 0}, preventOverflow: {ordre: 300, activé:! 0 , fn: fonction (e, t) {var o = t.objectifs_environnement || p (e.instance.popper); e.instance.reference === o && (o = p (o)); var n = B ( 'transform'), i = e.instance.popper.style, r = i.top, s = i.left, d = i [n]; i.top = '', i.left = '', i [ n] = ''; var a = v (e.instance.popper, e.instance.référence, t.padding, o, e.positionFixe), i.top = r, i.left = s, i [n] = d, t.liés = a; var l = t.priorité, f = e.offsets.popper, m = {primaire: fonction (e) {var o = f [e]; retourne f [e] <a [e] &&! t.escapeWithReference && (o = $ (f [e], a [e])), ae ({}, e, o)}, secondaire: function (e) { var o = 'right' === e '' left '': 'top', n = f [o]; renvoie f [e]> a [e] &&! t.escapeWithReference && (n = J (f [o] , un [e] - ('right' === e? f.width: f.height))), ae ({}, o, n)}}; return l.forEach (fonction (e) {var t = -1 === ['left', 'top']. IndexOf (e)? 'Secondaire': 'primaire'; f = le ({}, f, m [t] (e))}), e .offsets.popper = f, e}, priorité: ['left', 'right', 'top', 'bottom'], remplissage: 5, boundariesElement: 'scrollParent'}, keepTogether: {order: 400, enabled: ! 0, fn: fonction (e) {var t = e.offsets, o = t.popper, n = t.référence, i = e.placement.split ('-') [0], r = Z, p = -1! == ['top', 'bottom'] .indexOf (i), s = p? 'droite': 'bas', d = p? 'gauche': 'haut', a = p? 'largeur': 'hauteur', retour o [s] <r (n [d]) && (e.offsets.popper [d] = r (n [d]) - o [a]), o [d]> r (n [s]) && (e.offsets.popper [d] = r (n [s])), e}}, flèche: {ordre: 500, activé:! 0, fn: fonction (e, o) {var n; si (! q (e.instance. modificateurs, 'arrow', 'keepTogether')) retour e; var i = o.élément; if ('chaîne' == typeof i) {if (i = e.instance.popper.querySelector (i),! i) return e;} else if (! e.instance.popper.contains (i)) retourne console.warn ('ATTENTION: `arrow.element` doit être fils de son élément popper!'), e; var r = e. placement.split ('-') [0], p = e.offsets, s = p.popper, d = p.référence, a = -1! == ['gauche', 'droite']. indexDe (r ), l = a? hauteur ':' largeur ', f = a?' Top ':' Gauche ', m = f.toLongueCase (), h = a?' gauche ':' haut ',c = a? 'bottom': 'right', u = S (i) [l]; d [c] -u <s [m] && (e.offsets.popper [m] - = s [m] - (d [c] -u)), d [m] + u> s [c] && (e.offsets.popper [m] + = d [m] + us [c]), e.offsets.popper = g (e.offsets.popper); var b = d [m] + d [l] / 2-u / 2, y = t (e.instance.popper), w = parseFloat (y ['marge' + f ], 10), E = parseFloat (y ['bordure' + f + 'Largeur'], 10), v = be.offsets.popper [m] -wE; retourne v = $ (J (s [l] -u , v), 0), e.arrowElement = i, e.offsets.arrow = (n = {}, ae (n, m, Q (v)), ae (n, h, ''), n), e}, élément: '[x-arrow]'}, flip: {ordre: 600, activé:! 0, fn: fonction (e, t) {if (W (e.instance.modifiers, 'interne')) return e; if (e.flipped && e.placement === e.originalPlacement) renvoie e; var o = v (e.instance.popper, e.instance.référence, t.padding, t.boundariesElement, e.positionFixed), n = e.placement.split ('-') [0], i = T (n), r = e.placement.split ('-') [1] || '', p = [];switch (t.behavior) {cas he.FLIP: p = [n, i]; break; cas h.CLOCKWISE: p = z (n); break; cas he.COUNTERCLOCKWISE: p = z (n,! 0) ; break; défaut: p = t.behavior;} return p.forEach (fonction (s, d) {if (n! == s || p.length === d + 1) renvoie e; n = e. placement.split ('-') [0], i = T (n); var a = e.offsets.popper, l = e.offsets.reference, f = Z, m = 'left' === n && f ( a.right)> f (l.left) || 'right' === n && f (a.gauche) <f (l.right) || 'top' === n && f (a.bottom)> f (l .top) || 'bottom' === n && f (a.top) <f (l.bond), h = f (a.gauche) <f (o.left), c = f (a.right)> f (o.right), g = f (a.top) <f (o.top), u = f (a.bottom)> f (o.bottom), b = 'gauche' === n && h || 'right' === n && c || 'top' === n && g || 'bottom' === n && u, y = -1! == ['en haut', 'en bas']. indexDe (n), w = !! t.flipVariations && (y && 'start' === r && h || y && 'end' === r && c ||! y && 'start' === r && g ||! y && 'fin' === r && u); (m || b || w) && (e.flipped = ! 0, (m || b) && (n = p [d + 1]), w && (r = G (r)), e.placement = n + (r? '-' + r: ''), e .offsets.popper = le ({}, e.offsets.popper, C (e.instance.popper, e.offsets.reference, e.placement)), e = P (e.instance.modifiers, e, 'flip '))}), e}, comportement:' flip ', padding: 5, boundariesElement:' viewport '}, interne: {order: 700, activé:! 1, fn: function (e) {var t = e. placement, o = t.split ('-') [0], n = e.offsets, i = n.popper, r = n.référence, p = -1! == ['gauche', 'droite'] .indexOf (o), s = -1 === ["haut", "gauche"]. indexOf (o); retour i [p? 'gauche': 'top'] = r [o] - (s? i [p? 'largeur': 'hauteur']: 0), e.placement = T (t), e.offsets.popper = g (i), e}}, masquer: {ordre: 800, activé :! 0, fn:function (e) {if (! q (e.instance.modifiers, 'hide', 'preventOverflow')) retourne e; var t = e.offsets.reference, o = D (e.instance.modifiers, fonction (e ) {return'preventOverflow '=== e.name}). boundaries; si (t.bottom <o.top || t.gauche> o.right || t.top> o.bottom || t.right < o.left) {if (! 0 === e.hide) renvoie e; e.hide =! 0, e.attributes ['x-out-of-boundaries'] = ''} else {if (! 1 === e.hide) return e; e.hide =! 1, e.attributes ['x-out-of-boundaries'] =! 1} return e}}, computeStyle: {order: 850, enabled :! 0, fn: fonction (e, t) {var o = tx, n = ty, i = e.offsets.popper, r = D (e.instance.modifiers, fonction (e) {return'applyStyle '=== e.name}). gpuAcceleration; void 0! == r && console.warn ('ATTENTION: l'option `gpuAcceleration` a été déplacée dans le modificateur` computeStyle` et ne sera plus supportée dans les futures versions de Popper.js!'); var s, d , a = void 0 === r? t.gpuAcceleration:r, l = p (e.instance.popper), f = u (l), m = {position: i.position}, h = {gauche: Z (i.left), en haut: Q (i.top) , en bas: Q (i.bottom), à droite: Z (i.right)}, c = 'bottom' === o? 'top': 'en bas', g = 'right' === n? 'left ':' right ', b = B (' transformer '); si (d =' bottom '== c? -f.height + h.bottom: h.top, s =' droite '== g? -f .width + h.right: h.left, a && b) m [b] = 'translate3d (' + s + 'px,' + d + 'px, 0)', m [c] = 0, m [g] = 0 , m.willChange = 'transformer'; else {var y = 'bas' == c? -1: 1, w = 'droite' == g -1 -1; m [c] = d * y, m [g] = s * w, m.willChange = c + ',' + g} var E = {"x-placement": e.placement}; return e.attributes = le ({}, E, e.attributes) , e.styles = le ({}, m, e.styles), e.arrowStyles = le ({}, e.offsets.arrow, e.arrowStyles), e}, gpuAcceleration:! 0, x: 'bas' , y: 'right'}, applyStyle: {ordre: 900, activé:! 0, fn:function (e) {return j (e.instance.popper, e.styles), K (e.instance.popper, e.attributs), e.arrowElement && Object.keys (e.arrowStyles) .length && j (e.arrowElement, e .arrowStyles), e}, onLoad: fonction (e, t, o, n, i) {var r = L (i, t, e, o.positionFixée), p = O (o.placement, r, t, e, o.modifiers.flip.boundariesElement, o.modifiers.flip.padding); return t.setAttribute ('x-placement', p), j (t, {position: o.positionFixed? 'fixe': 'absolute '}), o}, gpuAcceleration: void 0}}}, ce});positionFixed? 'fixed': 'absolute'}), o}, gpuAcceleration: void 0}}}, ce});positionFixed? 'fixed': 'absolute'}), o}, gpuAcceleration: void 0}}}, ce});
// # sourceMappingURL = popper.min.js.map